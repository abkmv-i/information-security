import struct

class TEA:
    def __init__(self, key):
        # Проверяем, что длина ключа составляет 16 байт (128 бит)
        assert len(key) == 16  # 128-битный ключ
        # Разбиваем ключ на 4 части по 32 бита (4x32 = 128 бит)
        self.key = struct.unpack('>4L', key)  # Разбиваем на 4 части по 32 бита

    def encrypt(self, block):
        # Распаковываем блок в два 32-битных целых числа v0 и v1
        v0, v1 = struct.unpack('>2L', block)
        # Извлекаем ключи
        k0, k1, k2, k3 = self.key
        delta, sum = 0x9E3779B9, 0  # Константы для шифрования
        mask = 0xFFFFFFFF  # Маска для 32-битных значений

        # Выполняем 32 раунда шифрования
        for _ in range(32):
            sum = (sum + delta) & mask  # Обновляем сумму
            # Шифруем с использованием ключа и текущих значений v0 и v1
            v0 = (v0 + (((v1 << 4) + k0) ^ (v1 + sum) ^ ((v1 >> 5) + k1))) & mask
            v1 = (v1 + (((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3))) & mask

        # Упаковываем зашифрованные значения v0 и v1 обратно в байты
        return struct.pack('>2L', v0, v1)

    def decrypt(self, block):
        # Распаковываем блок в два 32-битных целых числа v0 и v1
        v0, v1 = struct.unpack('>2L', block)
        # Извлекаем ключи
        k0, k1, k2, k3 = self.key
        delta, sum = 0x9E3779B9, 0xC6EF3720  # Константы для дешифрования
        mask = 0xFFFFFFFF  # Маска для 32-битных значений

        # Выполняем 32 раунда дешифрования
        for _ in range(32):
            # Дешифруем с использованием ключа и текущих значений v0 и v1
            v1 = (v1 - (((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3))) & mask
            v0 = (v0 - (((v1 << 4) + k0) ^ (v1 + sum) ^ ((v1 >> 5) + k1))) & mask
            sum = (sum - delta) & mask  # Обновляем сумму

        # Упаковываем расшифрованные значения v0 и v1 обратно в байты
        return struct.pack('>2L', v0, v1)